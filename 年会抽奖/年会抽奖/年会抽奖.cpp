/*今年公司年会的奖品特别给力，但获奖的规矩却很奇葩：
1. 首先，所有人员都将一张写有自己名字的字条放入抽奖箱中；
2. 待所有字条加入完毕，每人从箱中取一个字条；
3. 如果抽到的字条上写的就是自己的名字，那么“恭喜你，中奖了！”
现在告诉你参加晚会的人数，请你计算有多少概率会出现无人获奖？

输入描述 :输入包含多组数据，每组数据包含一个正整数n（2≤n≤20）。
输出描述 :对应每一组数据，以“xx.xx%”的格式输出发生无人获奖的概率。
*/
#include<iostream>
using namespace std;

int main(){
	//f(n) = (n-1)*(f(n-1)+f(n-2))
	long long ErrCount[21] = { 0, 0, 1 };
	long long SumCount[21] = { 0, 1, 2 };
	for (int i = 3; i <= 21; i++){
		ErrCount[i] = (i - 1)*(ErrCount[i - 1] + ErrCount[i - 2]);
		SumCount[i] = i*SumCount[i - 1];
	}
	int n;
	while (cin >> n){
		printf("%.2f%%\n", 100.0*ErrCount[n] / SumCount[n]);
	}
	return 0;
}

/*对于什么时候才算做都不获奖，当然是所有人都拿到了别人的名字，没有拿到自己的名字。
全部都不获奖的概率必定是由n个人都拿错的情况种数除n个人拿出的所有排列情况数。n个人拿出的所有排列情况数显然是n的阶乘。
假设a的名字没有被a拿到，其他n - 1个人都有可能拿到，即有n - 1种情况。假设b拿到了a的名字，那么对于b的名字有两种情况，
第一种是b的名字被a拿到了，也就是a、b互相拿到了对方的名字，那么对于其他n - 2个人互相拿错又是一个子问题f(n - 2).
第二种是b的名字没有被a拿到，则剩下的问题是子问题f(n - 1).
因此可得递推公式f(n) = (n - 1) * (f(n - 1) + f(n - 2)).
最终得出公式n人都不获奖的概率h(n) = (n - 1) * (f(n - 1) + f(n - 2)) / (n!).
*/